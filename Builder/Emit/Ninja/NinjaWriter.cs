using System.Text;
using LumenBuilder.Build;
using LumenBuilder.Common;
using LumenBuilder.Model;

namespace LumenBuilder
{

    namespace Emit
    {

        namespace Ninja
        {

            /// <summary>
            /// Emits Ninja build files.
            /// </summary>
            public sealed class NinjaWriter
            {
                private readonly BuildContext Context;

                /// <summary>
                /// Creates a new Ninja writer.
                /// </summary>
                public NinjaWriter(BuildContext Context)
                {
                    this.Context = Context;
                }

                /// <summary>
                /// Generates the Ninja build file content for the given build plan.
                /// </summary>
                public string Generate(BuildPlan Plan)
                {
                    var Sb = new StringBuilder();

                    Sb.AppendLine("# Generated by LumenBuilder");
                    Sb.AppendLine($"# Configuration: {Context.Configuration}");
                    Sb.AppendLine();

                    WriteRules(Sb);
                    Sb.AppendLine();

                    WriteCompileStatements(Sb, Plan);
                    Sb.AppendLine();

                    WriteLinkStatements(Sb, Plan);

                    return Sb.ToString();
                }

                /// <summary>
                /// Writes the Ninja build file to the specified output path.
                /// </summary>
                public void Write(string OutputPath, BuildPlan Plan)
                {
                    string Content = Generate(Plan);
                    string Dir = Path.GetDirectoryName(OutputPath) ?? ".";

                    if (!Directory.Exists(Dir))
                    {
                        Directory.CreateDirectory(Dir);
                    }
                    File.WriteAllText(OutputPath, Content);
                }

                /// <summary>
                /// Writes the Ninja build rules to the StringBuilder.
                /// </summary>
                private void WriteRules(StringBuilder Sb)
                {
                    string CFlags = GetCompilerFlags();

                    Sb.AppendLine($"cxx = {Context.Toolchain.CompilerPath}");
                    Sb.AppendLine($"ar = {Context.Toolchain.ArchiverPath}");
                    Sb.AppendLine();

                    Sb.AppendLine("rule compile");
                    Sb.AppendLine("  command = $cxx $cflags -c -o $out $in");
                    Sb.AppendLine("  description = Compiling $in");
                    Sb.AppendLine();

                    Sb.AppendLine("rule link");
                    Sb.AppendLine("  command = $cxx $ldflags -o $out $in $libs");
                    Sb.AppendLine("  description = Linking $out");
                    Sb.AppendLine();

                    Sb.AppendLine("rule archive");
                    Sb.AppendLine("  command = $ar rcs $out $in");
                    Sb.AppendLine("  description = Archiving $out");
                }

                /// <summary>
                /// Writes the compile statements to the StringBuilder.
                /// </summary>
                private void WriteCompileStatements(StringBuilder Sb, BuildPlan Plan)
                {
                    Sb.AppendLine("# Compile statements");

                    for (int CompUnitsIndex = 0; CompUnitsIndex < Plan.CompileUnits.Count; ++CompUnitsIndex)
                    {
                        var Unit = Plan.CompileUnits[CompUnitsIndex];
                        var IncludeFlags = BuildIncludeFlags(Unit.Includes);
                        var DefineFlags = BuildDefineFlags(Unit.Defines);

                        Sb.Append("build ");
                        Sb.Append(EscapePath(Unit.ObjectFile));
                        Sb.Append(": compile ");
                        Sb.AppendLine(EscapePath(Unit.SourceFile));

                        Sb.Append("  cflags = ");
                        Sb.Append(GetCompilerFlags());
                        Sb.Append(' ');
                        Sb.Append(IncludeFlags);
                        Sb.Append(' ');
                        Sb.AppendLine(DefineFlags);
                    }
                }

                /// <summary>
                /// Writes the link statements to the StringBuilder.
                /// </summary>
                private void WriteLinkStatements(StringBuilder Sb, BuildPlan Plan)
                {
                    Sb.AppendLine("# Link statements");

                    for (int LinkIndex = 0; LinkIndex < Plan.LinkTargets.Count; ++LinkIndex)
                    {
                        var Target = Plan.LinkTargets[LinkIndex];
                        string Rule = Target.Type == ModuleType.StaticLibrary ? "archive" : "link";

                        Sb.Append("build ");
                        Sb.Append(EscapePath(Target.OutputFile));
                        Sb.Append(": ");
                        Sb.Append(Rule);

                        for (int ObjFilesIndex = 0; ObjFilesIndex < Target.ObjectFiles.Count; ++ObjFilesIndex)
                        {
                            Sb.Append(' ');
                            Sb.Append(EscapePath(Target.ObjectFiles[ObjFilesIndex]));
                        }

                        if (Target.DependencyPaths.Count > 0)
                        {
                            Sb.Append(" |");
                            for (int DepPathsIndex = 0; DepPathsIndex < Target.DependencyPaths.Count; ++DepPathsIndex)
                            {
                                Sb.Append(' ');
                                Sb.Append(EscapePath(Target.DependencyPaths[DepPathsIndex]));
                            }
                        }

                        Sb.AppendLine();

                        if (Target.Type != ModuleType.StaticLibrary && Target.DependencyPaths.Count > 0)
                        {
                            Sb.Append("  libs =");
                            for (int TargetDepPathsIndex = 0; TargetDepPathsIndex < Target.DependencyPaths.Count; ++TargetDepPathsIndex)
                            {
                                Sb.Append(" \"");
                                Sb.Append(Target.DependencyPaths[TargetDepPathsIndex]);
                                Sb.Append('"');
                            }
                            Sb.AppendLine();
                        }

                        if (Target.Type == ModuleType.SharedLibrary)
                        {
                            Sb.AppendLine("  ldflags = -shared");
                        }
                        else if (Target.Type == ModuleType.Executable)
                        {
                            Sb.AppendLine("  ldflags =");
                        }
                    }

                    Sb.AppendLine();
                    Sb.Append("build all: phony");
                    for (int LinkIndex = 0; LinkIndex < Plan.LinkTargets.Count; ++LinkIndex)
                    {
                        Sb.Append(' ');
                        Sb.Append(EscapePath(Plan.LinkTargets[LinkIndex].OutputFile));
                    }
                    Sb.AppendLine();
                    Sb.AppendLine("default all");
                }

                private string GetCompilerFlags()
                {
                    return Context.Configuration switch
                    {
                        BuildConfiguration.Debug => "-g -O0 -DDEBUG -std=c++20",
                        BuildConfiguration.Development => "-g -O2 -DNDEBUG -std=c++20",
                        BuildConfiguration.Release => "-O3 -DNDEBUG -std=c++20",
                        _ => "-std=c++20"
                    };
                }

                private static string BuildIncludeFlags(IReadOnlyList<string> Includes)
                {
                    if (Includes.Count == 0)
                    {
                        return "";
                    }

                    var Sb = new StringBuilder();

                    for (int IncIndex = 0; IncIndex < Includes.Count; ++IncIndex)
                    {
                        if (IncIndex > 0)
                        {
                            Sb.Append(' ');
                        }
                        Sb.Append("-I\"");
                        Sb.Append(Includes[IncIndex]);
                        Sb.Append('"');
                    }
                    return Sb.ToString();
                }

                private static string BuildDefineFlags(IReadOnlyList<string> Defines)
                {
                    if (Defines.Count == 0)
                    {
                        return "";
                    }

                    var Sb = new StringBuilder();

                    for (int DefIndex = 0; DefIndex < Defines.Count; ++DefIndex)
                    {
                        if (DefIndex > 0)
                        {
                            Sb.Append(' ');
                        }
                        Sb.Append("-D");
                        Sb.Append(Defines[DefIndex]);
                    }
                    return Sb.ToString();
                }

                private static string EscapePath(string Path)
                {
                    return Path.Replace(" ", "$ ").Replace(":", "$:");
                }

            }

        }

    }

}
