using System.Text;
using LumenBuilder.Build;
using LumenBuilder.Common;
using LumenBuilder.Model;

namespace LumenBuilder
{

    namespace Emit
    {

        namespace Makefile
        {

            /// <summary>
            /// Emits GNU Makefile build files.
            /// </summary>
            public sealed class MakefileWriter
            {
                private readonly BuildContext Context;

                /// <summary>
                /// Creates a new Makefile writer.
                /// </summary>
                public MakefileWriter(BuildContext Context)
                {
                    this.Context = Context;
                }

                /// <summary>
                /// Generates the Makefile content for the given build plan.
                /// </summary>
                public string Generate(BuildPlan Plan)
                {
                    var Sb = new StringBuilder();

                    Sb.AppendLine("# Generated by LumenBuilder");
                    Sb.AppendLine($"# Configuration: {Context.Configuration}");
                    Sb.AppendLine();

                    WriteVariables(Sb);
                    Sb.AppendLine();

                    WritePhonyTargets(Sb, Plan);
                    Sb.AppendLine();

                    WriteLinkTargets(Sb, Plan);
                    Sb.AppendLine();

                    WriteCompileTargets(Sb, Plan);

                    WriteCleanTarget(Sb);

                    return Sb.ToString();
                }

                /// <summary>
                /// Writes the Makefile to the specified output path.
                /// </summary>
                public void Write(string OutputPath, BuildPlan Plan)
                {
                    string Content = Generate(Plan);
                    string Dir = Path.GetDirectoryName(OutputPath) ?? ".";

                    if (!Directory.Exists(Dir))
                    {
                        Directory.CreateDirectory(Dir);
                    }
                    File.WriteAllText(OutputPath, Content);
                }

                /// <summary>
                /// Writes the variable definitions to the Makefile.
                /// </summary>
                private void WriteVariables(StringBuilder Sb)
                {
                    Sb.AppendLine($"CXX := {Context.Toolchain.CompilerPath}");
                    Sb.AppendLine($"AR := {Context.Toolchain.ArchiverPath}");
                    Sb.AppendLine($"CXXFLAGS := {GetCompilerFlags()}");
                    Sb.AppendLine("LDFLAGS :=");
                }

                /// <summary>
                /// Writes the phony targets and the 'all' target to the Makefile.
                /// </summary>
                private void WritePhonyTargets(StringBuilder Sb, BuildPlan Plan)
                {
                    Sb.Append(".PHONY: all clean");
                    for (int BuildOrdIndex = 0; BuildOrdIndex < Plan.BuildOrder.Count; ++BuildOrdIndex)
                    {
                        Sb.Append(' ');
                        Sb.Append(Plan.BuildOrder[BuildOrdIndex]);
                    }
                    Sb.AppendLine();
                    Sb.AppendLine();

                    Sb.Append("all:");
                    for (int LinkIndex = 0; LinkIndex < Plan.LinkTargets.Count; ++LinkIndex)
                    {
                        Sb.Append(' ');
                        Sb.Append(Plan.LinkTargets[LinkIndex].OutputFile);
                    }
                    Sb.AppendLine();
                }

                /// <summary>
                /// Writes the link targets to the Makefile.
                /// </summary>
                private void WriteLinkTargets(StringBuilder Sb, BuildPlan Plan)
                {
                    for (int LinkIndex = 0; LinkIndex < Plan.LinkTargets.Count; LinkIndex++)
                    {
                        var Target = Plan.LinkTargets[LinkIndex];

                        Sb.Append(Target.OutputFile);
                        Sb.Append(':');

                        for (int ObjFilesIndex = 0; ObjFilesIndex < Target.ObjectFiles.Count; ++ObjFilesIndex)
                        {
                            Sb.Append(' ');
                            Sb.Append(Target.ObjectFiles[ObjFilesIndex]);
                        }

                        for (int DepPathsIndex = 0; DepPathsIndex < Target.DependencyPaths.Count; ++DepPathsIndex)
                        {
                            Sb.Append(' ');
                            Sb.Append(Target.DependencyPaths[DepPathsIndex]);
                        }

                        Sb.AppendLine();

                        Sb.Append('\t');
                        Sb.Append("@mkdir -p $(dir $@)");
                        Sb.AppendLine();

                        Sb.Append('\t');
                        if (Target.Type == ModuleType.StaticLibrary)
                        {
                            Sb.Append("$(AR) rcs $@");
                            for (int TargetObjFilesIndex = 0; TargetObjFilesIndex < Target.ObjectFiles.Count; ++TargetObjFilesIndex)
                            {
                                Sb.Append(' ');
                                Sb.Append(Target.ObjectFiles[TargetObjFilesIndex]);
                            }
                        }
                        else
                        {
                            Sb.Append("$(CXX)");
                            if (Target.Type == ModuleType.SharedLibrary)
                            {
                                Sb.Append(" -shared");
                            }
                            Sb.Append(" -o $@");
                            for (int TargetObjFilesIndex = 0; TargetObjFilesIndex < Target.ObjectFiles.Count; ++TargetObjFilesIndex)
                            {
                                Sb.Append(' ');
                                Sb.Append(Target.ObjectFiles[TargetObjFilesIndex]);
                            }
                            for (int TargetDepPathsIndex = 0; TargetDepPathsIndex < Target.DependencyPaths.Count; ++TargetDepPathsIndex)
                            {
                                Sb.Append(" \"");
                                Sb.Append(Target.DependencyPaths[TargetDepPathsIndex]);
                                Sb.Append('"');
                            }
                        }
                        Sb.AppendLine();
                        Sb.AppendLine();
                    }
                }

                /// <summary>
                /// Writes the compile targets to the Makefile.
                /// </summary>
                private void WriteCompileTargets(StringBuilder Sb, BuildPlan Plan)
                {
                    for (int CompUnitsIndex = 0; CompUnitsIndex < Plan.CompileUnits.Count; ++CompUnitsIndex)
                    {
                        var Unit = Plan.CompileUnits[CompUnitsIndex];

                        Sb.Append(Unit.ObjectFile);
                        Sb.Append(": ");
                        Sb.AppendLine(Unit.SourceFile);

                        Sb.Append('\t');
                        Sb.AppendLine("@mkdir -p $(dir $@)");

                        Sb.Append('\t');
                        Sb.Append("$(CXX) $(CXXFLAGS)");

                        for (int UnitIncIndex = 0; UnitIncIndex < Unit.Includes.Count; ++UnitIncIndex)
                        {
                            Sb.Append(" -I\"");
                            Sb.Append(Unit.Includes[UnitIncIndex]);
                            Sb.Append('"');
                        }

                        for (int UnitDefIndex = 0; UnitDefIndex < Unit.Defines.Count; ++UnitDefIndex)
                        {
                            Sb.Append(" -D");
                            Sb.Append(Unit.Defines[UnitDefIndex]);
                        }

                        Sb.Append(" -c -o $@ $<");
                        Sb.AppendLine();
                        Sb.AppendLine();
                    }
                }

                /// <summary>
                /// Writes the clean target to the Makefile.
                /// </summary>
                private void WriteCleanTarget(StringBuilder Sb)
                {
                    Sb.AppendLine("clean:");
                    Sb.AppendLine($"\trm -rf {Paths.IntermediateDir} {Paths.BinariesDir}");
                }

                /// <summary>
                /// Gets the compiler flags based on the build configuration.
                /// </summary>
                private string GetCompilerFlags()
                {
                    return Context.Configuration switch
                    {
                        BuildConfiguration.Debug => "-g -O0 -DDEBUG -std=c++20",
                        BuildConfiguration.Development => "-g -O2 -DNDEBUG -std=c++20",
                        BuildConfiguration.Release => "-O3 -DNDEBUG -std=c++20",
                        _ => "-std=c++20"
                    };
                }

            }

        }

    }

}
